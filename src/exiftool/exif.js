// exiftool.js/exif

// summary:
//    The "main tags" for exiftool.js

// description:
//    reference : http://search.cpan.org/dist/Image-ExifTool/lib/Image/ExifTool/TagNames.pod

// returns:
//    objects with tags for EXIF, GPS, TIFF with their references and UNKNOWN (no reference)

/* TODO 
// - UserComment returns pointer if empty
*/

exports.tags = {
	
	/* note : tags 0xfde8-0xfdea and 0xfe4c-0xfe58 are generated by Photoshop Camera RAW. 
	// we added PS as prefix
	*/
	/* note : tags prefixed with _ basically are data about metadata for internal use.
	*/

	// version tags
	0x9000 : 'ExifVersion', 			// EXIF version
	0xA000 : 'FlashpixVersion', 		// Flashpix format version

	// colorspace tags
	0xA001 : 'ColorSpace', 				// Color space information tag
	0xA500 : 'Gamma', 					// Dec. value of coefficient gamma

	// image configuration
	0xA002 : 'PixelXDimension', 		// Valid width of meaningful image
	0xA003 : 'PixelYDimension', 		// Valid height of meaningful image
	0x9101 : 'ComponentsConfiguration', // Information about channels
	0x9102 : 'CompressedBitsPerPixel', 	// Compressed bits per pixel

	// user information
	0x927C : '_IFDpointer_Makernote',	// Any desired information written by the manufacturer
	0xc6f5 : '_IFDpointer_Profile',		// Any desired information about the color profile
	0x9286 : 'UserComment', 			// Comments by user
	0x9212 : 'SecurityClassification',
	

	// related file
	0xA004 : 'RelatedSoundFile', 		// Name of related sound file

	// date and time
	0x9003 : 'DateTimeOriginal', 		// Date and time when the original image was generated
	0x9004 : 'DateTimeDigitized', 		// Date and time when the image was stored digitally
	0x9290 : 'SubsecTime', 				// Fractions of seconds for DateTime
	0x9291 : 'SubsecTimeOriginal', 		// Fractions of seconds for DateTimeOriginal
	0x9292 : 'SubsecTimeDigitized', 	// Fractions of seconds for DateTimeDigitized
	0x882A : 'TimeZoneOffset', 			// 1 or 2 values (hours) - 2nd is optional :
										// 1) DateTimeOriginal offset from GMT, 2) offset of ModifyDate
	// picture-taking conditions
	0x829A : 'ExposureTime', 			// Exposure time (in seconds)
	0x829D : 'FNumber', 				// F number
	0x8822 : 'ExposureProgram', 		// Exposure program
	0x8824 : 'SpectralSensitivity', 	// Spectral sensitivity
	0x8827 : 'ISO', 					// ISO speed rating (ISOSpeedRatings in 2.2, PhotographicSensitivity in 2.3)
	0x8828 : 'OECF', 					// Optoelectric conversion factor
	0x8830 : 'SensitivityType', 		// Which one of the parameters of ISO12232 is the PhotographicSensitivity tag
	0x8831 : 'StandardOutputSensitivity',// When recording this, PhotographicSensitivity + SensitivityType tags shall also be recorded
	0x8832 : 'RecommendedExposureIndex',// Recommended exposure index value of a camera or input device
	0x8833 : 'ISOSpeed', 				// ISO 12232 speed value
	0x8834 : 'ISOSpeedLatitudeyyy', 	// ISO speed latitude yyy value of a camera or input device that is defined in ISO 12232
	0x8835 : 'ISOSpeedLatitudezzz', 	// ISO speed latitude zzz value of a camera or input device that is defined in ISO 12232.
	0x9201 : 'ShutterSpeedValue', 		// Shutter speed
	0x9202 : 'ApertureValue', 			// Lens aperture
	0x9203 : 'BrightnessValue', 		// Value of brightness
	0x9204 : 'ExposureBias', 			// Exposure bias
	0x9205 : 'MaxApertureValue', 		// Smallest F number of lens
	0x9206 : 'SubjectDistance', 		// Distance to subject in meters
	0x9207 : 'MeteringMode', 			// Metering mode
	0x9208 : 'LightSource', 			// Kind of light source
	0x9209 : 'Flash', 					// Flash status
	0x9214 : 'SubjectArea', 			// Location and area of main subject
	0x920A : 'FocalLength', 			// Focal length of the lens in mm
	0xA20B : 'FlashEnergy', 			// Strobe energy in BCPS
	0xA20E : 'FocalPlaneXResolution', 	// Number of pixels in width direction per FocalPlaneResolutionUnit
	0xA20F : 'FocalPlaneYResolution', 	// Number of pixels in height direction per FocalPlaneResolutionUnit
	0xA210 : 'FocalPlaneResolutionUnit',// Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution
	0xA214 : 'SubjectLocation', 		// Location of subject in image
	0xA215 : 'ExposureIndex', 			// Exposure index selected on camera
	0xA217 : 'SensingMethod', 			// Image sensor type
	0xA300 : 'FileSource', 				// Image source (3 == DSC)
	0xA301 : 'SceneType', 				// Scene type (1 == directly photographed)
	0xA302 : 'CFAPattern', 				// Color filter array geometric pattern
	0xA401 : 'CustomRendered', 			// Special processing
	0xA402 : 'ExposureMode', 			// Exposure mode
	0xA403 : 'WhiteBalance', 			// 1 = auto white balance, 2 = manual
	0xA404 : 'DigitalZoomRatio', 		// Digital zoom ratio
	0xA405 : 'FocalLengthIn35mmFilm', 	// Equivalent focal length assuming 35mm film camera (in mm)
	0xA406 : 'SceneCaptureType', 		// Type of scene
	0xA407 : 'GainControl', 			// Degree of overall image gain adjustment
	0xA408 : 'Contrast', 				// Direction of contrast processing applied by camera
	0xA409 : 'Saturation', 				// Direction of saturation processing applied by camera
	0xA40A : 'Sharpness', 				// Direction of sharpness processing applied by camera
	0xA40C : 'SubjectDistanceRange', 	// Distance to subject
	0x882B : 'SelfTimerMode', 			// self timer mode
	0xA432 : 'LensSpecification', 
	/*
	// This tag notes minimum focal length, maximum focal length, minimum F number in the minimum focal length, 
	// and minimum F number in the maximum focal length, which are specification information for the used lens.
	// When the minimum F number is unknown, the notation is 0/0.
	*/
	0xA433 : 'LensMake', 				// Lens manufacturer
	0xA434 : 'LensModel', 				// Lens's model name and model number, might be more detailed in makernote
	0xFDE8 : 'PSOwnerName',
	0xFDE9 : 'PSSerialNumber',
	0xFDEA : 'PSLens',
	0xFE4C : 'PSRawFile',
	0xFE4D : 'PSConverter',
	0xFE4E : 'PSWhiteBalance',
	0xFE51 : 'PSExposure',
	0xFE52 : 'PSShadows',
	0xFE53 : 'PSBrightness',
	0xFE54 : 'PSContrast',
	0xFE55 : 'PSSaturation',
	0xFE56 : 'PSSharpness',
	0xFE57 : 'PSSmoothness',
	0xFE58 : 'PSMoireFilter',
	
	// other tags		
	0x014A : '_IFDpointer_Sub',
	0xA005 : '_IFDpointer_Interop',
	0xEA1C : '_Padding',
	0xEA1D : '_OffsetSchema',	
	0x02BC : 'ApplicationNotes',
	0x9211 : 'ImageNumber', 			// Image Identifier as shown by camera
	0x9213 : 'ImageHistory', 			// History values
	0xA420 : 'ImageUniqueID', 			// Identifier assigned uniquely to each image
	0xA430 : 'OwnerName', 				// (CameraOwnerName in EXIF spec.)
	0xA431 : 'SerialNumber', 			// for when SerialNumber is in EXIF directly (BodySerialNumber in EXIF spec)
	0xA435 : 'LensSerialNumber' 		// for when LensSerialNumber is in EXIF directly
};

exports.tiffTags = {
	0x8769 : '_IFDpointer_EXIF',
	0x8825 : '_IFDpointer_GPS',
	0xA005 : '_IFDpointer_Interoperability',
	0xFE00 : '_IFDpointer_KDC',
	0x014A : '_IFDpointer_Sub',
	0x0100 : 'ImageWidth',
	0x0101 : 'ImageHeight',
	0x0102 : 'BitsPerSample',
	0x0103 : 'Compression',
	0x0106 : 'PhotometricInterpretation',
	0x0112 : 'Orientation',
	0x0115 : 'SamplesPerPixel',
	0x011C : 'PlanarConfiguration',
	0x0212 : 'YCbCrSubSampling',
	0x0213 : 'YCbCrPositioning',
	0x011A : 'XResolution',
	0x011B : 'YResolution',
	0x0128 : 'ResolutionUnit',
	0x0111 : 'StripOffsets',
	0x0116 : 'RowsPerStrip',
	0x0117 : 'StripByteCounts',
	0x0201 : 'ThumbnailOffset', 
	0x0202 : 'ThumbnailLength', 
	0x012D : 'TransferFunction',
	0x013E : 'WhitePoint',
	0x013F : 'PrimaryChromaticities',
	0x0211 : 'YCbCrCoefficients',
	0x0214 : 'ReferenceBlackWhite',
	0x0132 : 'DateTime',
	0x010E : 'ImageDescription',
	0x010F : 'Make',
	0x0110 : 'Model',
	0x0131 : 'Software',
	0x013B : 'Artist',
	0x8298 : 'Copyright',
	0xA431 : 'SerialNumber', 		// for when SerialNumber is in IFD0 directly (BodySerialNumber in EXIF spec)
	0xA435 : 'LensSerialNumber', 	// for when LensSerialNumber is in IFD0 directly
	0x0107 : 'Thresholding',
	0x0108 : 'CellWidth',
	0x0109 : 'CellLength',
	0x010A : 'FillOrder',
	0x010D : 'DocumentName',
	0x0111 : 'StripOffsets',
	0x0117 : 'SamplesPerPixel',
	0x0117 : 'StripByteCounts',
	0x0118 : 'MinSampleValue',
	0x0119 : 'MaxSampleValue',
	0x011D : 'PageName',
	0x011E : 'XPosition',
	0x011F : 'YPosition',
	0x0128 : 'ResolutionUnit',
	0x0129 : 'PageNumber',
	0x013C : 'HostComputer',
	0x013D : 'Predictor',
	0x0141 : 'HalftoneHints',
	0x0142 : 'TileWidth',
	0x0143 : 'TileLength',
	0x014C : 'InkSet',
	0x0150 : 'DotRange',
	0x87af : 'GeoTiffDirectory',
	0x87b0 : 'GeoTiffDoubleParams',
	0x87b1 : 'GeoTiffAsciiParams',
	0xC612 : 'DNGVersion',
	0xC613 : 'DNGBackwardVersion',
	0xC614 : 'UniqueCameraModel',
	0xC615 : 'LocalizedCameraModel',
	0x9C9B : 'XPTitle',
	0x9C9C : 'XPComment',
	0x9C9D : 'XPAuthor',
	0x9C9E : 'XPKeywords',
	0x9C9F : 'XPSubject',
	0xC621 : 'ColorMatrix1',
	0xC622 : 'ColorMatrix2',
	0xC623 : 'CameraCalibration1',
	0xC624 : 'CameraCalibration2',
	0xC625 : 'ReductionMatrix1',
	0xC626 : 'ReductionMatrix2',
	0xC627 : 'AnalogBalance',
	0xC628 : 'AsShotNeutral',
	0xC629 : 'AsShotWhiteXY',
	0xC62A : 'BaselineExposure',
	0xC62B : 'BaselineNoise',
	0xC62C : 'BaselineSharpness',
	0xC62E : 'LinearResponseLimit',
	0xC62F : 'CameraSerialNumber',
	0xC630 : 'DNGLensInfo',
	0xC633 : 'ShadowScale',
	0xC634 : 'DNGPrivateData',
	0xC635 : 'MakerNoteSafety',
	0xC65A : 'CalibrationIlluminant1',
	0xC65B : 'CalibrationIlluminant2',
	0xC65D : 'RawDataUniqueID',
	0xC68B : 'OriginalRawFileName',
	0xC68C : 'OriginalRawFileData',
	0xC68F : 'AsShotICCProfile',
	0xC690 : 'AsShotPreProfileMatrix',
	0xC691 : 'CurrentICCProfile',
	0xC692 : 'CurrentPreProfileMatrix',
	0xC6BF : 'ColorimetricReference',
	0xC6D2 : 'PanasonicTitle',
	0xC6D3 : 'PanasonicTitle2',
	0xC6F3 : 'CameraCalibrationSig',
	0xC6F4 : 'ProfileCalibrationSig',
	0xC6F6 : 'AsShotProfileName',
	0xC6F8 : 'ProfileName',
	0xC6F9 : 'ProfileHueSatMapDims',
	0xC6FA : 'ProfileHueSatMapData1',
	0xC6FB : 'ProfileHueSatMapData2',
	0xC6FC : 'ProfileToneCurve',
	0xC6FD : 'ProfileEmbedPolicy',
	0xC6FE : 'ProfileCopyright',
	0xC714 : 'ForwardMatrix1',
	0xC715 : 'ForwardMatrix2',
	0x0122 : 'GrayResponseUnit',
	0x0123 : 'GrayResponseCurve',
	0xC716 : 'PreviewApplicationName',
	0xC717 : 'PreviewApplicationVersion',
	0xC718 : 'PreviewSettingsName',
	0xC719 : 'PreviewSettingsDigest',
	0xC71A : 'PreviewColorSpace',
	0xC71B : 'PreviewDateTime',
	0xC71C : 'RawImageDigest',
	0xC71D : 'OriginalRawFileDigest',
	0xC725 : 'ProfileLookTableDims',
	0xC726 : 'ProfileLookTableData',
	0xC763 : 'TimeCodes',
	0xC764 : 'FrameRate',
	0xC772 : 'TStop',
	0xC789 : 'ReelName',
	0xC791 : 'OriginalDefaultFinalSize',
	0xC792 : 'OriginalBestQualitySize',
	0xC793 : 'OriginalDefaultCropSize',
	0xC7A1 : 'CameraLabel',
	0xC7A3 : 'ProfileHueSatMapEncoding',
	0xC7A4 : 'ProfileLookTableEncoding',
	0xC7A5 : 'BaselineExposureOffset',
	0xC7A6 : 'DefaultBlackRender',
	0xC7A7 : 'NewRawImageDigest',
	0xC7A8 : 'RawToPreviewGain',
	0x8546 : 'SEMInfo',
	0x4746 : 'Rating',
	0x4749 : 'RatingPercent',
	// 0x83bb : 'IPTC-NAA' 
	// TODO - FIXME - implement redaktor.iptc, test e.g. CanonEOS-1D.jpg
	// and write IPTC to .iptc container
};

exports.gpsTags = {
	0x0000 : 'GPSVersion',
	0x0001 : 'GPSLatitudeRef',
	0x0002 : 'GPSLatitude',
	0x0003 : 'GPSLongitudeRef',
	0x0004 : 'GPSLongitude',
	0x0005 : 'GPSAltitudeRef',
	0x0006 : 'GPSAltitude',
	0x0007 : 'GPSTimeStamp',
	0x0008 : 'GPSSatellites',
	0x0009 : 'GPSStatus',
	0x000A : 'GPSMeasureMode',
	0x000B : 'GPSDOP',
	0x000C : 'GPSSpeedRef',
	0x000D : 'GPSSpeed',
	0x000E : 'GPSTrackRef',
	0x000F : 'GPSTrack',
	0x0010 : 'GPSImgDirectionRef',
	0x0011 : 'GPSImgDirection',
	0x0012 : 'GPSMapDatum',
	0x0013 : 'GPSDestLatitudeRef',
	0x0014 : 'GPSDestLatitude',
	0x0015 : 'GPSDestLongitudeRef',
	0x0016 : 'GPSDestLongitude',
	0x0017 : 'GPSDestBearingRef',
	0x0018 : 'GPSDestBearing',
	0x0019 : 'GPSDestDistanceRef',
	0x001A : 'GPSDestDistance',
	0x001B : 'GPSProcessingMethod',
	0x001C : 'GPSAreaInformation',
	0x001D : 'GPSDateStamp',
	0x001E : 'GPSDifferential',
	0x001F : 'GPSHPositioningError'
};

exports.unknownTags = {
	/* Tags which are not in the EXIF spec. but might be present */
	0xA20C : 'SpatialFrequencyResponse',
	0xA40B : 'DeviceSettingDescription',
	0x0120 : 'FreeOffsets',
	0x0121 : 'FreeByteCounts',
	0x0124 : 'T4Options',
	0x0125 : 'T6Options',
	0x012C : 'ColorResponseUnit',
	0x0140 : 'ColorMap',
	0x0144 : 'TileOffsets',
	0x0145 : 'TileByteCounts',
	0x0146 : 'BadFaxLines',
	0x0147 : 'CleanFaxData',
	0x0148 : 'ConsecutiveBadFaxLines',
	0x014D : 'InkNames',
	0x014E : 'NumberofInks',
	0x0151 : 'TargetPrinter',
	0x0152 : 'ExtraSamples',
	0x0153 : 'SampleFormat',
	0x0154 : 'SMinSampleValue',
	0x0155 : 'SMaxSampleValue',
	0x0156 : 'TransferRange',
	0x0157 : 'ClipPath',
	0x0158 : 'XClipPathUnits',
	0x0159 : 'YClipPathUnits',
	0x015A : 'Indexed',
	0x015B : 'JPEGTables',
	0x015F : 'OPIProxy',
	0x0190 : 'GlobalParametersIFD',
	0x0191 : 'ProfileType',
	0x0192 : 'FaxProfile',
	0x0193 : 'CodingMethods',
	0x0194 : 'VersionYear',
	0x0195 : 'ModeNumber',
	0x01B1 : 'Decode',
	0x01B2 : 'DefaultImageColor',
	0x01B3 : 'T82Options',
	0x01B5 : 'JPEGTables',
	0x0200 : 'JPEGProc',
	0x0203 : 'JPEGRestartInterval',
	0x0205 : 'JPEGLosslessPredictors',
	0x0206 : 'JPEGPointTransforms',
	0x0207 : 'JPEGQTables',
	0x0208 : 'JPEGDCTables',
	0x0209 : 'JPEGACTables',
	0x022F : 'StripRowCounts',
	0x03E7 : 'USPTOMiscellaneous',
	0x1000 : 'RelatedImageFileFormat',
	0x1001 : 'RelatedImageWidth',
	0x1002 : 'RelatedImageHeight',
	0x4747 : 'XP_DIP_XML',
	0x4748 : 'StitchInfo',
	0x800D : 'ImageID',
	0x80A3 : 'WangTag1',
	0x80A4 : 'WangAnnotation',
	0x80A5 : 'WangTag3',
	0x80A6 : 'WangTag4',
	0x80E3 : 'Matteing',
	0x80E4 : 'DataType',
	0x80E5 : 'ImageDepth',
	0x80E6 : 'TileDepth',
	0x827D : 'Model2',
	0x828D : 'CFARepeatPatternDim',
	0x828E : 'CFAPattern2',
	0x828F : 'BatteryLevel',
	0x8290 : 'KodakIFD',
	0x82A5 : 'MDFileTag',
	0x82A6 : 'MDScalePixel',
	0x82A7 : 'MDColorTable',
	0x82A8 : 'MDLabName',
	0x82A9 : 'MDSampleInfo',
	0x82AA : 'MDPrepDate',
	0x82AB : 'MDPrepTime',
	0x82AC : 'MDFileUnits',
	0x830E : 'PixelScale',
	0x8335 : 'AdventScale',
	0x8336 : 'AdventRevision',
	0x835C : 'UIC1Tag',
	0x835D : 'UIC2Tag',
	0x835E : 'UIC3Tag',
	0x835F : 'UIC4Tag',
	0x847E : 'IntergraphPacketData',
	0x847F : 'IntergraphFlagRegisters',
	0x8480 : 'IntergraphMatrix',
	0x8481 : 'INGRReserved',
	0x8482 : 'ModelTiePoint',
	0x84E0 : 'Site',
	0x84E1 : 'ColorSequence',
	0x84E2 : 'IT8Header',
	0x84E3 : 'RasterPadding',
	0x84E4 : 'BitsPerRunLength',
	0x84E5 : 'BitsPerExtendedRunLength',
	0x84E6 : 'ColorTable',
	0x84E7 : 'ImageColorIndicator',
	0x84E8 : 'BackgroundColorIndicator',
	0x84E9 : 'ImageColorValue',
	0x84EA : 'BackgroundColorValue',
	0x84EB : 'PixelIntensityRange',
	0x84EC : 'TransparencyIndicator',
	0x84ED : 'ColorCharacterization',
	0x84EE : 'HCUsage',
	0x84EF : 'TrapIndicator',
	0x84F0 : 'CMYKEquivalent',
	0x85B8 : 'PixelMagicJBIGOptions',
	0x85D8 : 'ModelTransform',
	0x8602 : 'WB_GRGBLevels',
	0x8606 : 'LeafData',
	0x8649 : 'PhotoshopSettings',
	0x8773 : 'ICC_Profile',
	0x877F : 'TIFF_FXExtensions',
	0x8780 : 'MultiProfiles',
	0x8781 : 'SharedData',
	0x8782 : 'T88Options',
	0x87AC : 'ImageLayer',
	0x8829 : 'Interlace',
	0x885C : 'FaxRecvParams',
	0x885D : 'FaxSubAddress',
	0x885E : 'FaxRecvTime',
	0x888A : 'LeafSubIFD',
	0x920D : 'Noise',
	0x920E : 'FocalPlaneXResolution',
	0x920F : 'FocalPlaneYResolution',
	0x9210 : 'FocalPlaneResolutionUnit',
	0x9215 : 'ExposureIndex',
	0x9216 : 'TIFF-EPStandardID',
	0x9217 : 'SensingMethod',
	0x923A : 'CIP3DataFile',
	0x923B : 'CIP3Sheet',
	0x923C : 'CIP3Side',
	0x923F : 'StoNits',
	0x932F : 'MSDocumentText',
	0x9330 : 'MSPropertySetStorage',
	0x9331 : 'MSDocumentTextPosition',
	0x935C : 'ImageSourceData',
	0xA20C : 'SpatialFrequencyResponse',
	0xA20D : 'Noise',
	0xA211 : 'ImageNumber',
	0xA212 : 'SecurityClassification',
	0xA213 : 'ImageHistory',
	0xA216 : 'TIFF-EPStandardID',
	0xA480 : 'GDALMetadata',
	0xA481 : 'GDALNoData',
	0xAFC0 : 'ExpandSoftware',
	0xAFC1 : 'ExpandLens',
	0xAFC2 : 'ExpandFilm',
	0xAFC3 : 'ExpandFilterLens',
	0xAFC4 : 'ExpandScanner',
	0xAFC5 : 'ExpandFlashLamp',
	0xBC01 : 'PixelFormat',
	0xBC02 : 'Transformation',
	0xBC03 : 'Uncompressed',
	0xBC04 : 'ImageType',
	0xBC80 : 'ImageWidth',
	0xBC81 : 'ImageHeight',
	0xBC82 : 'WidthResolution',
	0xBC83 : 'HeightResolution',
	0xBCC0 : 'ImageOffset',
	0xBCC1 : 'ImageByteCount',
	0xBCC2 : 'AlphaOffset',
	0xBCC3 : 'AlphaByteCount',
	0xBCC4 : 'ImageDataDiscard',
	0xBCC5 : 'AlphaDataDiscard',
	0xC427 : 'OceScanjobDesc',
	0xC428 : 'OceApplicationSelector',
	0xC429 : 'OceIDNumber',
	0xC42A : 'OceImageLogic',
	0xC44F : 'Annotations',
	0xC4A5 : 'PrintIM',
	0xC580 : 'USPTOOriginalContentType',
	0xC616 : 'CFAPlaneColor',
	0xC617 : 'CFALayout',
	0xC618 : 'LinearizationTable',
	0xC619 : 'BlackLevelRepeatDim',
	0xC61A : 'BlackLevel',
	0xC61B : 'BlackLevelDeltaH',
	0xC61C : 'BlackLevelDeltaV',
	0xC61D : 'WhiteLevel',
	0xC61E : 'DefaultScale',
	0xC61F : 'DefaultCropOrigin',
	0xC620 : 'DefaultCropSize',
	0xC62D : 'BayerGreenSplit',
	0xC631 : 'ChromaBlurRadius',
	0xC632 : 'AntiAliasStrength',
	0xC640 : 'RawImageSegmentation',
	0xC65C : 'BestQualityScale',
	0xC660 : 'AliasLayerMetadata',
	0xC68D : 'ActiveArea',
	0xC68E : 'MaskedAreas',
	0xC6F5 : 'ProfileIFD',
	0xC6F7 : 'NoiseReductionApplied',
	0xC71E : 'SubTileBlockSize',
	0xC71F : 'RowInterleaveFactor',
	// TODO 0x9009 - opcodes written e.g. by Google Plus uploader
	0x9009 : 'OpcodeGoogle',
	0xC740 : 'OpcodeList1',
	0xC741 : 'OpcodeList2',
	0xC74E : 'OpcodeList3',
	0xC761 : 'NoiseProfile',
	0xC7B5 : 'DefaultUserCrop',
	0x8568 : 'AFCP_IPTC'
};

exports.ref = {
	/* helper functions - TODO might go in helper module */
	_arr: function(arr){
		var total = 0;
		for (var i = 0, n = arr.length; i < n; ++i){
			if ( typeof arr[i] !== 'number' ) return { value: arr, _val:arr };
			total += arr[i];
		}
		return (total==0) ? { value: 'None', _val:0 } : { value:arr, _val:arr };
	},
	_obj: function(anyValue, anyRawVal){
		if (typeof anyValue === 'object' && '_val' in anyValue){ 
			return (anyValue._val === 0xFFFF || anyValue._val === 0xdeadbeef) ? false : anyValue;
		} else if (typeof anyRawVal === 'undefined'){ 
			anyRawVal = anyValue;
		}
		if (anyRawVal === 0xFFFF || anyRawVal === 0xdeadbeef) return false;
		return { value: anyValue, _val: anyRawVal }
	},
	px: function(i, prefix){ 
		var str = (prefix!=null && prefix===true) ? 'px '.concat(i) : ''.concat(i, ' px');
		return (typeof i === 'number') ? { value:str, _val:i } : { value:i, _val:i };
	},
	decbin: function(dec,length){
		var out = "";
		while(length--)
		out += (dec >> length ) & 1;    
		return out;  
	},
	bitmask: function(val, mask, length, reversed){
		var maskStr = exports.ref.decbin(val, length);
		if (typeof reversed!=='undefined' && reversed===true){
			maskStr = maskStr.split('').reverse().join('');
		}
		var rStr = '';
		for (var i = 0, len = maskStr.length; i < len; i++) {
			if ( parseInt(maskStr[i])===1 ) rStr = rStr.concat( mask[i], ', ' );
		}
		rStr = (rStr.length===0) ? '(none)' : rStr.slice(0,-2);
		return rStr;
	},
	multiple: function(arr,ref,_length){
		if (arr instanceof Array){
			var res = { multipleValues: {} }
			for(var key in ref){
				
				var raw = exports.ref._obj(arr[key]);
				if ( typeof raw === 'object' && key in arr ){
					res.multipleValues[ref[key].desc] = raw;
					if ('charCodes' in ref[key] && typeof ref[key].charCodes === 'object'){
						var rStr = '';
						for( var ckey in ref[key].charCodes ){
							rStr = rStr.concat( String.fromCharCode(arr[ref[key]['charCodes'][ckey]]) );
						}
						//{ value:(arr[4] in _distort) ? _distort[arr[4]] : arr[4], _val:arr[4] }
						res.multipleValues[ref[key].desc] = exports.ref._obj(rStr, arr[key]);
					}
					if ('fn' in ref[key] && typeof ref[key].fn === 'function'){
						res.multipleValues[ref[key].desc] = exports.ref._obj(ref[key].fn());
					}
					if ('values' in ref[key]){
						if (arr[key] == -1) arr[key] = '_';
						res.multipleValues[ref[key].desc] = (arr[key] in ref[key].values) ?  exports.ref._obj(ref[key].values[arr[key]], arr[key]) : raw;
					}
				}
			}
			return res;
		}
		return { value:arr, _val:arr }
	},
	arrToDeg: function(nArr, lRef){
		var deg = parseFloat(nArr[0]), m = parseFloat(nArr[1]), s = parseFloat(nArr[2]);
		if (s==0 && m>0){
			var _m = Math.floor(m);
			s = (m-_m)*60;
			m = _m;
			_m = null;	
		}
		if (typeof deg !== 'number' || typeof m !== 'number' || typeof s !== 'number') return {value:nArr, _val:nArr};
		if (lRef === 'South' || lRef === 'North' || lRef === 'East' || lRef === 'West') {
			var ref = lRef.substr(0,1); 
			var rI = (ref == 'S' || ref == 'W') ? -1 : 1;
			var v = (deg+(m/60)+(s/3600)) * rI;
			if( v===0 && ref==='S') ref = 'N';
			if( v===0 && ref==='W') ref = 'E';
			return { 
				value: deg.toString().concat('° ', m, '\' ', s.toFixed(4), '" ', ref), 
				_val: (typeof v === 'number') ? v : [deg, m, s] 
			};
		}
		return {value:[deg, m, s], _val:nArr};
	},
	decToFrac: function(_n){
		var n = (typeof _n == 'number') ? _n : parseInt(_n);
		if (typeof n == 'number'){
			if (n===0) return {value:0, _val:0};
			var pref = (n>0) ? '+' : '-';
			var df = 1, top = 1, bot = 1;
			var limit = 1e5;
			var __n = Math.abs(n);
			while (df != __n && limit-- > 0) {
				if (df < __n) {
					top += 1;
				}
				else {
					bot += 1;
					top = parseInt(__n * bot, 10);
				}
				df = top / bot;
			}
			__n = null;
			/* note : some vendors handle infinite values incorrect or have "finetuned" values
			// e.g. Leica exposureCompensation: '-85/256 EV' / -0.33203125
			*/
			var roundArr = (bot/top).toFixed(1).split('.');
			if (roundArr instanceof Array && roundArr[1] == '0'){
				top = 1;
				bot = roundArr[0];
			}
			return {value:pref+top.toString().concat('/', bot, ' EV'), _val:n};
		}
		return {value:n, _val:_n}; 
	},
	versions: function(data, count){ 
		if (!(data instanceof Array)) return { value:data, _val:data };
		if (typeof count === 'number') {
			if (count<data.length) return { value:data, _val:data };
			data = data.slice(0,count);
		}
		for (var i = 0; i < data.length; i++) {
			data[i] = String.fromCharCode( data[i] );
		} 
		var vStr = data.join('').trim().replace(/^0/, '').replace(/\0+$/, '');
		var v = parseInt(vStr);
		return (typeof v === 'number' && !isNaN(v) && v!=0) ? { value:(v/100).toFixed(2), _val:data } : { value:vStr, _val:data };
	},
	distance: function(v, infV){
		if (typeof v !== 'number') return { value:0, _val:0 }
		return { value:(v > infV) ? "inf" : v.toString().concat(' m'), _val:v }	
	},
	expoTime: function(t){
		if (typeof t === 'number' && t < 0.25001 && t > 0) {
			return {value:'1/'.concat(Math.floor(0.5 + 1/t)), _val:t};
		}
		return (typeof t === 'number') ? {value:t.toFixed(1).replace(/\.0$/, ''), _val:t} : {value:t.replace(/\.0$/, ''), _val:t};
	},
	aperture: function(n){
		var v = (typeof n == 'number') ? Math.pow(2, (n / 2)) : n;
		return (typeof v == 'number') ? {value:v.toFixed(1), _val:v} : {value:n, _val:n};
	},
	focal: function(n){
		var v = (typeof n === 'number') ? n.toFixed(1).replace('.0','') : n;
		return (typeof n === 'number') ? {value:v.concat(' mm'), _val:n} : {value:n, _val:n};	
	},
	size: function(n, units, type){
		if (typeof units !== 'string') units = '';
		if (typeof type !== 'string')  type = '';
		return (typeof n === 'number') ? {value:n.toString().concat(' ',units,' ',type), _val:n} : {value:n, _val:n};
	},
	lv: function(aperture, shutter, iso){
		var check = new RegExp(/([+-]?(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?)/);
		if (check.test(aperture) && check.test(shutter) && check.test(iso)){
			var a = (typeof aperture === 'number') ? aperture : parseInt(aperture);
			var b = (typeof shutter === 'number') ? shutter : parseInt(shutter);
			var c = (typeof iso === 'number') ? iso : parseInt(iso);
			return (2*Math.log(a) - Math.log(b) - Math.log(c/100)) / Math.log(2);
		} 
		return false;
		
	},
	printLensInfo: function(arr){
		if (arr instanceof Array && arr.length>3 && typeof arr[0] === 'number'){
			var lStr = arr[0].toString();
			if (arr[1]!=arr[0]) lStr = lStr.concat('-',arr[1]);
			lStr = lStr.concat('mm f/',arr[2]);
			if (arr[3]!=arr[2]) lStr = lStr.concat('-',arr[3]);
			return {value:lStr, _val:arr};
		}
		return {value:arr, _val:arr};
	},
	plusminus: function(n){
		if (typeof n === 'number' && n>0) { 
			return { value:'+'.concat(n), _val:n };
		} else {
			return { value: (typeof n !== 'number' || n===0) ? 'Off' : n.toString(), _val:n };
		}	
	},
	
	timezone: function(arr){
		/* not used yet - see Nikon:TimezoneIssue */
	},
	/* helper end */
	
	ExifVersion: function(data){ return exports.ref.versions(data); },		
	InteropVersion: function(data){ return exports.ref.versions(data); },
	FlashpixVersion: function(data){ return exports.ref.versions(data); },
	
	PixelXDimension: function(n){ return exports.ref.size(n, 'px', 'w'); },
	PixelYDimension: function(n){ return exports.ref.size(n, 'px', 'h'); },
	
	OldSubfileType: {
		1: 'Full-resolution image',
		2: 'Reduced-resolution image',
		3: 'Single page of multi-page image'
	},
	SubsecTime: function(n){ var _n = parseInt(n); return (typeof _n === 'number' && !isNaN(_n)) ? {value:_n, _val:_n} : {value:n, _val:n}; }, 
	SubsecTimeOriginal: function(n){ var _n = parseInt(n); return (typeof _n === 'number' && !isNaN(_n)) ? {value:_n, _val:_n} : {value:n, _val:n}; }, 
	SubsecTimeDigitized: function(n){ var _n = parseInt(n); return (typeof _n === 'number' && !isNaN(_n)) ? {value:_n, _val:_n} : {value:n, _val:n}; }, 
	/* TODO : this has no file type (yet) while redaktor.meta.js has
	'Compression'
	%compression = (
		1: 'Uncompressed',
		2: 'CCITT 1D',
		3: 'T4/Group 3 Fax',
		4: 'T6/Group 4 Fax',
		5: 'LZW',
		6: 'JPEG (old-style)', //3
		7: 'JPEG', //4
		8: 'Adobe Deflate', //3
		9: 'JBIG B&W', //3
		10: 'JBIG Color', //3
		99: 'JPEG', //16
		262: 'Kodak 262', //16
		32766: 'Next', //3
		32767: 'Sony ARW Compressed', //16
		32769: 'Packed RAW', //PH (used by Epson, Nikon, Samsung)
		32770: 'Samsung SRW Compressed', //PH
		32771: 'CCIRLEW', //3
		32773: 'PackBits',
		32809: 'Thunderscan', //3
		32867: 'Kodak KDC Compressed', //PH
		32895: 'IT8CTPAD', //3
		32896: 'IT8LW', //3
		32897: 'IT8MP', //3
		32898: 'IT8BL', //3
		32908: 'PixarFilm', //3
		32909: 'PixarLog', //3
		32946: 'Deflate', //3
		32947: 'DCS', //3
		34661: 'JBIG', //3
		34676: 'SGILog', //3
		34677: 'SGILog24', //3
		34712: 'JPEG 2000', //3
		34713: 'Nikon NEF Compressed', //PH
		34715: 'JBIG2 TIFF FX', //20
		34718: 'Microsoft Document Imaging (MDI) Binary Level Codec', //18
		34719: 'Microsoft Document Imaging (MDI) Progressive Transform Codec', //18
		34720: 'Microsoft Document Imaging (MDI) Vector', //18
		34892: 'Lossy JPEG', // (DNG 1.4)
		65000: 'Kodak DCR Compressed', //PH
		65535: 'Pentax PEF Compressed', //Jens
	);
	sub IdentifyRawFile($$){
		my ($et, $comp) = @_;
		if ($$et{FILE_TYPE} eq 'TIFF' and not $$et{IdentifiedRawFile}) {
			if ($compression{$comp} and $compression{$comp} =~ /^\w+ ([A-Z]{3}) Compressed$/) {
				$et->OverrideFileType($$et{TIFF_TYPE} = $1);
				$$et{IdentifiedRawFile} = 1;
			}
		}
	}
	*/
	
	photometricInterpretation: {
		0: 'WhiteIsZero',
		1: 'BlackIsZero',
		2: 'RGB',
		3: 'RGB Palette',
		4: 'Transparency Mask',
		5: 'CMYK',
		6: 'YCbCr',
		8: 'CIELab',
		9: 'ICCLab', //3
		10: 'ITULab', //3
		32803: 'Color Filter Array', //2
		32844: 'Pixar LogL', //3
		32845: 'Pixar LogLuv', //3
		34892: 'Linear Raw', //2
	},
	Orientation : {
		1: 'Horizontal (normal)',
		2: 'Mirror horizontal',
		3: 'Rotate 180',
		4: 'Mirror vertical',
		5: 'Mirror horizontal and rotate 270 CW',
		6: 'Rotate 90 CW',
		7: 'Mirror horizontal and rotate 90 CW',
		8: 'Rotate 270 CW'
	},
	Thresholding : {
		1: 'No dithering or halftoning',
		2: 'Ordered dither or halftone',
		3: 'Randomized dither'
	},
	FillOrder : {
		1: 'Normal',
		2: 'Reversed'
	},
	PlanarConfiguration : {
		1: 'Chunky',
		2: 'Planar'
	},
	GrayResponseUnit : { 
		1: 0.1,
		2: 0.001,
		3: 0.0001,
		4: 0.00001,
		5: 0.000001
	},
	T4Options : {
		0: '2-Dimensional encoding',
		1: 'Uncompressed',
		2: 'Fill bits added'
	},
	T6Options : { 1: 'Uncompressed' },
	ResolutionUnit : {
		1: 'unknown',
		2: 'inches',
		3: 'cm'
	},
	Predictor : {
		1: 'None',
		2: 'Horizontal differencing'
	},
	CleanFaxData : {
		0: 'Clean',
		1: 'Regenerated',
		2: 'Unclean'
	},
	ExtraSamples : { 
		0: 'Unspecified',
		1: 'Associated Alpha',
		2: 'Unassociated Alpha'
	},
	Indexed : { 0: 'Not indexed', 1: 'Indexed' },
	OPIProxy : {
		0: 'Higher resolution image does not exist',
		1: 'Higher resolution image exists'
	},
	ProfileType: { 0: 'Unspecified', 1: 'Group 3 FAX' },
	FaxProfile : {
		0: 'Unknown',
		1: 'Minimal B&W lossless, S',
		2: 'Extended B&W lossless, F',
		3: 'Lossless JBIG B&W, J',
		4: 'Lossy color and grayscale, C',
		5: 'Lossless color and grayscale, L',
		6: 'Mixed raster content, M',
		7: 'Profile T', 
		255: 'Multi Profiles'
	},
	CodingMethods : {
		0: 'Unspecified compression',
		1: 'Modified Huffman',
		2: 'Modified Read',
		3: 'Modified MR',
		4: 'JBIG',
		5: 'Baseline JPEG',
		6: 'JBIG color'
	},
	JPEGProc : {
		1: 'Baseline',
		14: 'Lossless'
	},
	Copyright : function(data){
		data = data.replace(/ *\0/, String.fromCharCode(10));
		data = data.replace(/ *\0[\s\S]*/, '');
		return { value:data.replace(/\n$/, '').trim() };
	},
	ModelTiePoint : { 2: 'Location' },
	RasterPadding : { 
		0: 'Byte',
		1: 'Word',
		2: 'Long Word',
		9: 'Sector',
		10: 'Long Sector'
	},
	ImageColorIndicator : { 
		0: 'Unspecified Image Color',
		1: 'Specified Image Color'
	},
	BackgroundColorIndicator : { 
		0: 'Unspecified Background Color',
		1: 'Specified Background Color'
	},
	HCUsage : { 
		0: 'CT',
		1: 'Line Art',
		2: 'Trap'
	},
	TIFF_FXExtensions : {
		/* BITMASK */
		0: 'Resolution/Image Width',
		1: 'N Layer Profile M',
		2: 'Shared Data',
		3: 'B&W JBIG2',
		4: 'JBIG2 Profile M'
	},
	MultiProfiles : {
		0: 'Profile S',
		1: 'Profile F',
		2: 'Profile J',
		3: 'Profile C',
		4: 'Profile L',
		5: 'Profile M',
		6: 'Profile T',
		7: 'Resolution/Image Width',
		8: 'N Layer Profile M',
		9: 'Shared Data',
		10: 'JBIG2 Profile M'
	},
	/* TODO
	'GeoTiffDirectory', 'GeoTiffDoubleParams',
		RawConv: '$val . GetByteOrder()', // save byte order
	*/
	ExposureProgram : {
		0: 'Not Defined',
		1: 'Manual',
		2: 'Program AE',
		3: 'Aperture-priority AE',
		4: 'Shutter speed priority AE',
		5: 'Creative (Slow speed)',
		6: 'Action (High speed)',
		7: 'Portrait',
		8: 'Landscape',
		9: 'Bulb'
	},
	SpectralSensitivity : { 2: 'Camera' },
	SensitivityType : {
		0: 'Unknown',
		1: 'Standard Output Sensitivity',
		2: 'Recommended Exposure Index',
		3: 'ISO Speed',
		4: 'Standard Output Sensitivity and Recommended Exposure Index',
		5: 'Standard Output Sensitivity and ISO Speed',
		6: 'Recommended Exposure Index and ISO Speed',
		7: 'Standard Output Sensitivity, Recommended Exposure Index and ISO Speed',
	},
	ComponentsConfiguration : function(data){
		var c = ['',  'Y', 'Cb', 'Cr', 'R', 'G', 'B'];
		var cStr = '';
		if (data instanceof Array){
			if (data.join().trim() == '4,5,6,0') return {value:'RGB uncompressed', _val:data};
			if (data.join().trim() == '1,2,3,0') return {value:'Y, Cb, Cr, -', _val:data};
			data.forEach(function(index){
				cStr.concat(c[index],', ');
			});
			return {value:cStr, _val:data};
		}
		return data;
	},
	XResolution: function(n){
		var v = (typeof n == 'number') ? n.toFixed(8) : n;
		return { value:v, _val:n };
	},
	YResolution: function(n){
		var v = (typeof n == 'number') ? n.toFixed(8) : n;
		return { value:v, _val:n };
	},
	PrimaryChromaticities: function(n){
		return (n instanceof Array) ? { value:n.join(' '), _val:n } : { value:n, _val:n };	
	}, 
	WhitePoint: function(n){
		return (n instanceof Array) ? { value:n.join(' '), _val:n } : { value:n, _val:n };	
	}, 
	ReferenceBlackWhite: function(n){
		return (n instanceof Array) ? { value:n.join(' '), _val:n } : { value:n, _val:n };	
	}, 
	ShutterSpeedValue : function(n){ 
		var v = (typeof n === 'number' && Math.abs(n)<100) ? Math.pow(2,-Math.abs(n)) : 0;
		return exports.ref.expoTime(v); 
	},
	ApertureValue : function(data){ return exports.ref.aperture(data); },
	MaxApertureValue : function(data){ return exports.ref.aperture(data); },
	ExposureCompensation : function(data){ return exports.ref.decToFrac(data); },
	SubjectDistance : function(data){ 
		return (typeof data === 'string' && data.match(/^(inf|undef)$/)) ? {value:data, _val:data} : {value:data.toString().concat(' m'), _val:data};
	}, 
	FocalLength : function(data){ return exports.ref.focal(data); },
	FocalLengthIn35mmFilm : function(data){ return exports.ref.focal(data); },
	FocalPlaneResolutionUnit : {
		1: 'None',
		2: 'inches',
		3: 'cm',
		4: 'mm',
		5: 'um',
	},
	FocalPlaneXResolution: function(n){
		var v = (typeof n == 'number') ? n.toFixed(6) : n;
		return { value:v, _val:n };
	}, 
	FocalPlaneYResolution: function(n){
		var v = (typeof n == 'number') ? n.toFixed(6) : n;
		return { value:v, _val:n };
	}, 
	SecurityClassification : {
		T: 'Top Secret',
		S: 'Secret',
		C: 'Confidential',
		R: 'Restricted',
		U: 'Unclassified',
	},
	SensingMethod : {
		1: 'Monochrome area', 
		2: 'One-chip color area',
		3: 'Two-chip color area',
		4: 'Three-chip color area',
		5: 'Color sequential area',
		6: 'Monochrome linear', // 12 (not standard EXIF)
		7: 'Trilinear',
		8: 'Color sequential linear'
	},
	ColorSpace : {
		1 : 'sRGB'
	},
	MeteringMode : {
		0: 'Unknown',
		1: 'Average',
		2: 'Center-weighted average',
		3: 'Spot',
		4: 'Multi-spot',
		5: 'Multi-segment',
		6: 'Partial',
		255: 'Other',
	},
	LightSource : {
		0 : 'Unknown',
		1 : 'Daylight',
		2 : 'Fluorescent',
		3 : 'Tungsten (incandescent light)',
		4 : 'Flash',
		9 : 'Fine weather',
		10 : 'Cloudy weather',
		11 : 'Shade',
		12 : 'Daylight fluorescent (D 5700 - 7100K)',
		13 : 'Day white fluorescent (N 4600 - 5400K)',
		14 : 'Cool white fluorescent (W 3900 - 4500K)',
		15 : 'White fluorescent (WW 3200 - 3700K)',
		16 : 'Warm White Fluorescent', 
		17 : 'Standard light A',
		18 : 'Standard light B',
		19 : 'Standard light C',
		20 : 'D55',
		21 : 'D65',
		22 : 'D75',
		23 : 'D50',
		24 : 'ISO studio tungsten',
		255 : 'Other'
	},
	Flash : {
		0x0000 : 'No Flash',
		0x0001 : 'On, Flash fired',
		0x0005 : 'On, Flash fired, strobe return light not detected',
		0x0007 : 'On, Flash fired, strobe return light detected',
		0x0008 : 'On, Did not fire',
		0x0009 : 'On, Flash fired, compulsory flash mode',
		0x000D : 'On, Flash fired, compulsory flash mode, strobe return light not detected',
		0x000F : 'On, Flash fired, compulsory flash mode, strobe return light detected',
		0x0010 : 'Off, Flash did not fire',
		0x0018 : 'Auto, Flash did not fire',
		0x0019 : 'Auto, Flash fired',
		0x001D : 'Auto, Flash fired, strobe return light not detected',
		0x001F : 'Auto, Flash fired, strobe return light detected',
		0x0020 : 'Off, No flash function',
		0x0041 : 'On, Flash fired, red-eye reduction mode',
		0x0045 : 'On, Flash fired, red-eye reduction mode, strobe return light not detected',
		0x0047 : 'On, Flash fired, red-eye reduction mode, strobe return light detected',
		0x0049 : 'On, Flash fired, compulsory flash mode, red-eye reduction mode',
		0x004D : 'On, Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
		0x004F : 'On, Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
		0x0050 : 'Off, Red-eye reduction',
		0x0058 : 'Auto, Did not fire, Red-eye reduction',
		0x0059 : 'Auto, Flash fired, auto mode, red-eye reduction mode',
		0x005D : 'Auto, Flash fired, auto mode, strobe return light not detected, red-eye reduction mode',
		0x005F : 'Auto, Flash fired, auto mode, strobe return light detected, red-eye reduction mode'
	},
	SceneCaptureType : {
		0 : 'Standard',
		1 : 'Landscape',
		2 : 'Portrait',
		3 : 'Night scene'
	},
	WhiteBalance : {
		0 : 'Auto',
		1 : 'Manual'
	},
	GainControl : {
		0 : 'None',
		1 : 'Low gain up',
		2 : 'High gain up',
		3 : 'Low gain down',
		4 : 'High gain down'
	},
	Contrast : {
		0 : 'Normal',
		1 : 'Soft',
		2 : 'Hard'
	},
	Saturation : {
		0 : 'Normal',
		1 : 'Low saturation',
		2 : 'High saturation'
	},
	Sharpness : {
		0 : 'Normal',
		1 : 'Soft',
		2 : 'Hard'
	},
	SubjectDistanceRange : {
		0 : 'Unknown',
		1 : 'Macro',
		2 : 'Close view',
		3 : 'Distant view'
	},
	ExposureTime : function(data){ return exports.ref.expoTime(data); },
	FileSource : function(data){
		var fs = {1: 'Film Scanner', 2: 'Reflection Print Scanner', 3: 'Digital Camera'};
        if (data instanceof Array && data.length == 4 && data[0] == 3) return { value:'Sigma Digital Camera', _val:3 };
		return (data in fs) ? { value:fs[data], _val:data } : { value:data, _val:data };
	},
	SceneType :	function(data){
		if (typeof data === 'number' || typeof data === 'string') data = [data];
		return (data[0]===1) ? { value:'Directly photographed', _val:1 } : { value:(parseInt(data)||data), _val:data };
	},
	PixelFormat : {
		0x0d: '24-bit RGB',
		0x0c: '24-bit BGR',
		0x0e: '32-bit BGR',
		0x15: '48-bit RGB',
		0x12: '48-bit RGB Fixed Point',
		0x3b: '48-bit RGB Half',
		0x18: '96-bit RGB Fixed Point',
		0x1b: '128-bit RGB Float',
		0x0f: '32-bit BGRA',
		0x16: '64-bit RGBA',
		0x1d: '64-bit RGBA Fixed Point',
		0x3a: '64-bit RGBA Half',
		0x1e: '128-bit RGBA Fixed Point',
		0x19: '128-bit RGBA Float',
		0x10: '32-bit PBGRA',
		0x17: '64-bit PRGBA',
		0x1a: '128-bit PRGBA Float',
		0x1c: '32-bit CMYK',
		0x2c: '40-bit CMYK Alpha',
		0x1f: '64-bit CMYK',
		0x2d: '80-bit CMYK Alpha',
		0x20: '24-bit 3 Channels',
		0x21: '32-bit 4 Channels',
		0x22: '40-bit 5 Channels',
		0x23: '48-bit 6 Channels',
		0x24: '56-bit 7 Channels',
		0x25: '64-bit 8 Channels',
		0x2e: '32-bit 3 Channels Alpha',
		0x2f: '40-bit 4 Channels Alpha',
		0x30: '48-bit 5 Channels Alpha',
		0x31: '56-bit 6 Channels Alpha',
		0x32: '64-bit 7 Channels Alpha',
		0x33: '72-bit 8 Channels Alpha',
		0x26: '48-bit 3 Channels',
		0x27: '64-bit 4 Channels',
		0x28: '80-bit 5 Channels',
		0x29: '96-bit 6 Channels',
		0x2a: '112-bit 7 Channels',
		0x2b: '128-bit 8 Channels',
		0x34: '64-bit 3 Channels Alpha',
		0x35: '80-bit 4 Channels Alpha',
		0x36: '96-bit 5 Channels Alpha',
		0x37: '112-bit 6 Channels Alpha',
		0x38: '128-bit 7 Channels Alpha',
		0x39: '144-bit 8 Channels Alpha',
		0x08: '8-bit Gray',
		0x0b: '16-bit Gray',
		0x13: '16-bit Gray Fixed Point',
		0x3e: '16-bit Gray Half',
		0x3f: '32-bit Gray Fixed Point',
		0x11: '32-bit Gray Float',
		0x05: 'Black & White',
		0x09: '16-bit BGR555',
		0x0a: '16-bit BGR565',
		0x13: '32-bit BGR101010',
		0x3d: '32-bit RGBE',
	},
	Transformation : {
		0: 'Horizontal (normal)',
		1: 'Mirror vertical',
		2: 'Mirror horizontal',
		3: 'Rotate 180',
		4: 'Rotate 90 CW',
		5: 'Mirror horizontal and rotate 90 CW',
		6: 'Mirror horizontal and rotate 270 CW',
		7: 'Rotate 270 CW',
	},
	Uncompressed : { 0: 'No', 1: 'Yes' },
	ImageDataDiscard : {
		0: 'Full Resolution',
		1: 'Flexbits Discarded',
		2: 'HighPass Frequency Data Discarded',
		3: 'Highpass and LowPass Frequency Data Discarded',
	},
	AlphaDataDiscard : {
		0: 'Full Resolution',
		1: 'Flexbits Discarded',
		2: 'HighPass Frequency Data Discarded',
		3: 'Highpass and LowPass Frequency Data Discarded',
	},
	USPTOOriginalContentType : {
		0: 'Text or Drawing',
		1: 'Grayscale',
		2: 'Color',
	},
	CFAPattern : function(arr){ 
		/* The value consists of:
		- Two short, being the grid width and height of the repeated pattern.
		- Next, for every pixel in that pattern, an identification code.
		*/
		if ( (arr.reduce(function(a, b){return a + b;})) > 36 ) return '<truncated data>';
		if ( arr.length < 2 ) return '<zero pattern size>';
		var w = arr[1];
		var h = arr[3];
		if ( (4 + w * h) !== arr.length ) return '<truncated data>';
		var cfaColor = ['Red', 'Green', 'Blue', 'Cyan', 'Magenta', 'Yellow', 'White'];
		var rtn = '[';
		var r = 0;
		arr.forEach(function(index,i){
			if (i>3){
				r++; 
				var color = (index < cfaColor.length) ? cfaColor[index] : 0;
				rtn = rtn.concat( color );
				color = null;
				if (r==2){ rtn = rtn.concat(']['); r = 0; } else { rtn = rtn.concat(','); }
			}
		});
		return (rtn.indexOf('0')==-1) ? { value:rtn.slice(0,-1), _val:arr } : { value:arr, _val:arr }; 
	},
	CustomRendered : {
		0 : 'Normal',
		1 : 'Custom',
		4 : 'Apple iPhone5c horizontal orientation',
		6 : 'Apple iPhone5c panorama'
	},
	ExposureMode : {
		0: 'Auto',
		1: 'Manual',
		2: 'Auto bracket',
		3: 'Samsung EX/NX specific'
	},
	brackets: 	function(arr){
		if (arr instanceof Array && arr.length>2){
			var fInt = null;
			if (arr[2]==0){
				fInt = 0;	
			} else {
				fInt = (arr[0]*(arr[1]/arr[2]));
			}
			return (typeof fInt === 'number') ? { value:(fInt==0) ? 0 : fInt.toFixed(1), _val:fInt } : { value:0, _val:arr };
		}
		return { value:arr, _val:arr } 	
	},
	
	YCbCrPositioning : { 1: 'Centered', 2: 'Co-sited' },
	
	GPSVersion: 	function(data){
		return (data instanceof Array) ? { value:data.join('.'), _val:data } : { value:data, _val:data };
	},
	GPSLatitudeRef: function(data){
		var known = {N: 'North', S: 'South'};
		var i = parseInt(data);
		if (typeof data === 'string' && data in known){
			return {value:known[data], _val:data};
		} else if ( typeof i === 'number' && !isNaN(i) ){
			return (i<0) ? {value:known.S, _val:data} : {value:known.N, _val:data};
		}
		return {value:data, _val:data};
	},
	GPSLatitude: function(values, lRef){
		if ( values instanceof Array && values.length == 3 ) return exports.ref.arrToDeg(values, lRef);
		if ( (values instanceof Array && typeof values[0] === 'number') || typeof values === 'number'){ 
			return {value:values, _val:values};
		}
		return {value:'n/a', _val:values};
	},
	GPSLongitudeRef: function(data){
		var known = {E: 'East', W: 'West'};
		var i = parseInt(data);
		if (typeof data === 'string' && data in known){
			return {value:known[data], _val:data};
		} else if ( typeof i === 'number' && !isNaN(i) ){
			return (i<0) ? {value:known.W, _val:data} : {value:known.E, _val:data};
		}
		return {value:data, _val:data};
	},
	GPSLongitude: function(values, lRef){
		if ( values instanceof Array && values.length == 3 ) return exports.ref.arrToDeg(values, lRef);
		if ( (values instanceof Array && typeof values[0] === 'number') || typeof values === 'number'){ 
			return {value:values, _val:values};
		}
		return {value:'n/a', _val:values};
	},
	GPSAltitudeRef: { 0: 'Above Sea Level', 1: 'Below Sea Level' },
	GPSAltitude: function(data, aRef){
		var v = (typeof data === 'string') ? parseInt(data.replace(/\s*m$/, '')) : data;
		var ref = (v===0 && aRef==='Below Sea Level') ? 'Above Sea Level' : aRef;
		if (typeof v === 'number' && !isNaN(v)) return {value: v.toString().trim().concat(' m ', ref), _val: data};
		return {value:data, _val:data};		
	},
	GPSTimeStamp: function(data){ 
		var arr = (data instanceof Array) ? data.map(function (e){ return (typeof e==='number' && e<10) ? '0'.concat(e) : e.toString(); }) : data;
		return (arr instanceof Array) ? { value:arr.join(':'), _val:arr } : { value:arr, _val:arr }; 
	},
	GPSMeasureMode: { 2: '2-Dimensional Measurement', 3: '3-Dimensional Measurement' },
	GPSStatus: { A: 'Measurement Active', V: 'Measurement Void' },
	GPSSpeedRef: { K: 'km/h', M: 'mph', N: 'knots' },
	GPSTrackRef: { M: 'Magnetic North', T: 'True North' },
	GPSImgDirectionRef: { M: 'Magnetic North', T: 'True North' },
	GPSDestLatitudeRef: { N: 'North', S: 'South' },
	GPSDestLongitudeRef: { E: 'East', W: 'West' },
	GPSDestBearingRef: { M: 'Magnetic North', T: 'True North' },
	GPSDestDistanceRef: { K: 'Kilometers', M: 'Miles', N: 'Nautical Miles' },
	GPSDifferential: { 0: 'No Correction', 1: 'Differential Corrected' }
}

exports.postFn = function(res){
	if (typeof res !== 'object' || res === {}) return {};
	// "Composite Tags"
	var composite = {
		
		ImageSize: function(){
			var w = ('ImageWidth' in res) ? res.ImageWidth : (('PixelXDimension' in res) ? res.PixelXDimension : 'n/a');
			var h = ('ImageHeight' in res) ? res.ImageHeight : (('PixelYDimension' in res) ? res.PixelYDimension : 'n/a');
			// TODO use PixelXDimension/Height only for Canon and Phase One TIFF-base RAW images /^(CR2|Canon 1D RAW|IIQ|EIP)$/
			if (w!=='n/a' && h!=='n/a') return w+'x'+h;
			return false;
		},
		ShutterSpeed: function(){
			var vals = ['ExposureTime', 'ShutterSpeedValue', 'BulbDuration'];
			return (vals[2] in res && res[vals[2]]>0) ? res[vals[2]] : ((vals[0] in res) ? res[vals[0]] : res[vals[1]]);
		},
		Aperture: function(){
			return ('FNumber' in res) ? res.FNumber : (('ApertureValue' in res) ? res.ApertureValue : 'n/a');
		},
		LightValue: function(){
			var vals = ['Aperture', 'ShutterSpeed', 'ISO'];
			if (vals[0] in res && vals[1] in res && vals[2] in res){ 
				return exports.ref.lv(res[vals[0]], res[vals[1]], res[vals[2]]);
			}
			return false;
		},
		/*
		_: function(){
			
		},
		_: function(){
			
		},
		*/
	}
	var compositeRes = {};
	for ( var key in composite ){
		compositeRes[key] = composite[key]();
	}
	return compositeRes;
	/*
		FocalLength35efl: { #26/PH
			Description: 'Focal Length',
			Notes: 'this value may be incorrect if the image has been resized',
			Groups: { 2: 'Camera' },
			Require: {
				0: 'FocalLength',
			},
			Desire: {
				1: 'ScaleFactor35efl',
			},
			ValueConv: 'ToFloat(@val); ($val[0] || 0) * ($val[1] || 1)',
			PrintConv: '$val[1] ? sprintf("%.1f mm (35 mm equivalent: %.1f mm)", $val[0], $val) : sprintf("%.1f mm", $val)',
		},
		ScaleFactor35efl: { #26/PH
			Description: 'Scale Factor To 35 mm Equivalent',
			Notes: q{
				this value and any derived values may be incorrect if the image has been
				resized
			},
			Groups: { 2: 'Camera' },
			Desire: {
				0: 'FocalLength',
				1: 'FocalLengthIn35mmFormat',
				2: 'Composite:DigitalZoom',
				3: 'FocalPlaneDiagonal',
				4: 'SensorSize',
				5: 'FocalPlaneXSize',
				6: 'FocalPlaneYSize',
				7: 'FocalPlaneResolutionUnit',
				8: 'FocalPlaneXResolution',
				9: 'FocalPlaneYResolution',
			   10: 'PixelXDimension',
			   11: 'PixelYDimension',
			   12: 'CanonImageWidth',
			   13: 'CanonImageHeight',
			   14: 'ImageWidth',
			   15: 'ImageHeight',
			},
			ValueConv: 'Image::ExifTool::Exif::CalcScaleFactor35efl($self, @val)',
			PrintConv: 'sprintf("%.1f", $val)',
		},
		CircleOfConfusion: {
			Notes: q{
				calculated as D/1440, where D is the focal plane diagonal in mm.  This value
				may be incorrect if the image has been resized
			},
			Groups: { 2: 'Camera' },
			Require: 'ScaleFactor35efl',
			ValueConv: 'sqrt(24*24+36*36) / ($val * 1440)',
			PrintConv: 'sprintf("%.3f mm",$val)',
		},
		HyperfocalDistance: {
			Notes: 'this value may be incorrect if the image has been resized',
			Groups: { 2: 'Camera' },
			Require: {
				0: 'FocalLength',
				1: 'Aperture',
				2: 'CircleOfConfusion',
			},
			ValueConv: q{
				ToFloat(@val);
				return 'inf' unless $val[1] and $val[2];
				return $val[0] * $val[0] / ($val[1] * $val[2] * 1000);
			},
			PrintConv: 'sprintf("%.2f m", $val)',
		},
		DOF: {
			Description: 'Depth Of Field',
			Notes: 'this value may be incorrect if the image has been resized',
			Require: {
				0: 'FocalLength',
				1: 'Aperture',
				2: 'CircleOfConfusion',
			},
			Desire: {
				3: 'FocusDistance',   # focus distance in metres (0 is infinity)
				4: 'SubjectDistance',
				5: 'ObjectDistance',
			},
			ValueConv: q{
				ToFloat(@val);
				my ($d, $f) = ($val[3], $val[0]);
				if (defined $d) {
					$d or $d = 1e10;    # (use large number for infinity)
				} else {
					$d = $val[4] || $val[5];
					return undef unless defined $d;
				}
				return 0 unless $f and $val[2];
				my $t = $val[1] * $val[2] * ($d * 1000 - $f) / ($f * $f);
				my @v = ($d / (1 + $t), $d / (1 - $t));
				$v[1] < 0 and $v[1] = 0; # 0 means 'inf'
				return join(' ',@v);
			},
			PrintConv: q{
				$val =~ tr/,/./;    # in case locale is whacky
				my @v = split ' ', $val;
				$v[1] or return sprintf("inf (%.2f m - inf)", $v[0]);
				my $dof = $v[1] - $v[0];
				my $fmt = ($dof>0 and $dof<0.02) ? "%.3f" : "%.2f";
				return sprintf("$fmt m ($fmt - $fmt)",$dof,$v[0],$v[1]);
			},
		},
		FOV: {
			Description: 'Field Of View',
			Notes: q{
				calculated for the long image dimension.  This value may be incorrect for
				fisheye lenses, or if the image has been resized
			},
			Require: {
				0: 'FocalLength',
				1: 'ScaleFactor35efl',
			},
			Desire: {
				2: 'FocusDistance', # (multiply by 1000 to convert to mm)
			},
			# ref http://www.bobatkins.com/photography/technical/field_of_view.html
			# (calculations below apply to rectilinear lenses only, not fisheye)
			ValueConv: q{
				ToFloat(@val);
				return undef unless $val[0] and $val[1];
				my $corr = 1;
				if ($val[2]) {
					my $d = 1000 * $val[2] - $val[0];
					$corr += $val[0]/$d if $d > 0;
				}
				my $fd2 = atan2(36, 2*$val[0]*$val[1]*$corr);
				my @fov = ( $fd2 * 360 / 3.14159 );
				if ($val[2] and $val[2] > 0 and $val[2] < 10000) {
					push @fov, 2 * $val[2] * sin($fd2) / cos($fd2);
				}
				return join(' ', @fov);
			},
			PrintConv: q{
				my @v = split(' ',$val);
				my $str = sprintf("%.1f deg", $v[0]);
				$str .= sprintf(" (%.2f m)", $v[1]) if $v[1];
				return $str;
			},
		},
		# generate DateTimeOriginal from Date and Time Created if not extracted already
		DateTimeOriginal: {
			Condition: 'not defined $$self{VALUE}{DateTimeOriginal}',
			Description: 'Date/Time Original',
			Groups: { 2: 'Time' },
			Desire: {
				0: 'DateTimeCreated',
				1: 'DateCreated',
				2: 'TimeCreated',
			},
			RawConv: '($val[1] and $val[2]) ? $val : undef',
			ValueConv: q{
				return $val[0] if $val[0] and $val[0]=~/ /;
				return "$val[1] $val[2]";
			},
			PrintConv: '$self->ConvertDateTime($val)',
		},
		ThumbnailImage: {
			Writable: 1,
			WriteCheck: '$self->CheckImage(\$val)',
			WriteAlso: {
				# (the 0xfeedfeed values are translated in the Exif write routine)
				ThumbnailOffset: 'defined $val ? 0xfeedfeed : undef',
				ThumbnailLength: 'defined $val ? 0xfeedfeed : undef',
			},
			Require: {
				0: 'ThumbnailOffset',
				1: 'ThumbnailLength',
			},
			# retrieve the thumbnail from our EXIF data
			RawConv: 'Image::ExifTool::Exif::ExtractImage($self,$val[0],$val[1],"ThumbnailImage")',
		},
		PreviewImage: {
			Writable: 1,
			WriteCheck: '$self->CheckImage(\$val)',
			DelCheck: '$val = ""; return undef', # can't delete, so set to empty string
			WriteAlso: {
				PreviewImageStart : 'defined $val ? 0xfeedfeed : undef',
				PreviewImageLength: 'defined $val ? 0xfeedfeed : undef',
				PreviewImageValid : 'defined $val and length $val ? 1 : 0',
			},
			Require: {
				0: 'PreviewImageStart',
				1: 'PreviewImageLength',
			},
			Desire: {
				2: 'PreviewImageValid',
				# (DNG and A100 ARW may be have 2 preview images)
				3: 'PreviewImageStart (1)',
				4: 'PreviewImageLength (1)',
			},
			# note: extract 2nd preview, but ignore double-referenced preview
			# (in A100 ARW images, the 2nd PreviewImageLength from IFD0 may be wrong anyway)
			RawConv: q{
				if ($val[3] and $val[4] and $val[0] ne $val[3]) {
					my %val = (
						0: 'PreviewImageStart (1)',
						1: 'PreviewImageLength (1)',
						2: 'PreviewImageValid',
					);
					$self->FoundTag($tagInfo, \%val);
				}
				return undef if defined $val[2] and not $val[2];
				return Image::ExifTool::Exif::ExtractImage($self,$val[0],$val[1],'PreviewImage');
			},
		},
		JpgFromRaw: {
			Writable: 1,
			WriteCheck: '$self->CheckImage(\$val)',
			WriteAlso: {
				JpgFromRawStart : 'defined $val ? 0xfeedfeed : undef',
				JpgFromRawLength: 'defined $val ? 0xfeedfeed : undef',
			},
			Require: {
				0: 'JpgFromRawStart',
				1: 'JpgFromRawLength',
			},
			RawConv: 'Image::ExifTool::Exif::ExtractImage($self,$val[0],$val[1],"JpgFromRaw")',
		},
		OtherImage: {
			Writable: 1,
			WriteCheck: '$self->CheckImage(\$val)',
			DelCheck: '$val = ""; return undef', # can't delete, so set to empty string
			WriteAlso: {
				OtherImageStart : 'defined $val ? 0xfeedfeed : undef',
				OtherImageLength: 'defined $val ? 0xfeedfeed : undef',
			},
			Require: {
				0: 'OtherImageStart',
				1: 'OtherImageLength',
			},
			# retrieve the thumbnail from our EXIF data
			RawConv: 'Image::ExifTool::Exif::ExtractImage($self,$val[0],$val[1],"OtherImage")',
		},
		PreviewImageSize: {
			Require: {
				0: 'PreviewImageWidth',
				1: 'PreviewImageHeight',
			},
			ValueConv: '"$val[0]x$val[1]"',
		},
		SubSecDateTimeOriginal: {
			Description: 'Date/Time Original',
			Groups: { 2: 'Time' },
			Require: {
				0: 'EXIF:DateTimeOriginal',
				1: 'SubSecTimeOriginal',
			},
			# be careful here just in case there is a timezone following the seconds
			RawConv: '$val[1]=~/\d/ ? $val : undef',
			ValueConv: q{
				$_ = $val[0]; s/( \d{2}:\d{2}:\d{2})/$1\.$val[1]/; $_;
			},
			PrintConv: '$self->ConvertDateTime($val)',
		},
		SubSecCreateDate: {
			Description: 'Create Date',
			Groups: { 2: 'Time' },
			Require: {
				0: 'EXIF:CreateDate',
				1: 'SubSecTimeDigitized',
			},
			RawConv: '$val[1]=~/\d/ ? $val : undef',
			ValueConv: q{
				$_ = $val[0]; s/( \d{2}:\d{2}:\d{2})/$1\.$val[1]/; $_;
			},
			PrintConv: '$self->ConvertDateTime($val)',
		},
		SubSecModifyDate: {
			Description: 'Modify Date',
			Groups: { 2: 'Time' },
			Require: {
				0: 'EXIF:ModifyDate',
				1: 'SubSecTime',
			},
			RawConv: '$val[1]=~/\d/ ? $val : undef',
			ValueConv: q{
				$_ = $val[0]; s/( \d{2}:\d{2}:\d{2})/$1\.$val[1]/; $_;
			},
			PrintConv: '$self->ConvertDateTime($val)',
		},
		CFAPattern: {
			Require: {
				0: 'CFARepeatPatternDim',
				1: 'CFAPattern2',
			},
			# generate CFAPattern
			ValueConv: q{
				my @a = split / /, $val[0];
				my @b = split / /, $val[1];
				return '?' unless @a==2 and @b==$a[0]*$a[1];
				return "$a[0] $a[1] @b";
			},
			PrintConv: 'Image::ExifTool::Exif::PrintCFAPattern($val)',
		},
		RedBalance: {
			Groups: { 2: 'Camera' },
			Desire: {
				0: 'WB_RGGBLevels',
				1: 'WB_RGBGLevels',
				2: 'WB_RBGGLevels',
				3: 'WB_GRBGLevels',
				4: 'WB_GRGBLevels',
				5: 'WB_GBRGLevels',
				6: 'WB_RGBLevels',
				7: 'WB_GRBLevels',
				8: 'WB_RBLevels',
				9: 'WBRedLevel', # red
			   10: 'WBGreenLevel',
			},
			ValueConv: 'Image::ExifTool::Exif::RedBlueBalance(0,@val)',
			PrintConv: 'int($val * 1e6 + 0.5) * 1e-6',
		},
		BlueBalance: {
			Groups: { 2: 'Camera' },
			Desire: {
				0: 'WB_RGGBLevels',
				1: 'WB_RGBGLevels',
				2: 'WB_RBGGLevels',
				3: 'WB_GRBGLevels',
				4: 'WB_GRGBLevels',
				5: 'WB_GBRGLevels',
				6: 'WB_RGBLevels',
				7: 'WB_GRBLevels',
				8: 'WB_RBLevels',
				9: 'WBBlueLevel', # blue
			   10: 'WBGreenLevel',
			},
			ValueConv: 'Image::ExifTool::Exif::RedBlueBalance(1,@val)',
			PrintConv: 'int($val * 1e6 + 0.5) * 1e-6',
		},
		GPSPosition: {
			Groups: { 2: 'Location' },
			Require: {
				0: 'GPSLatitude',
				1: 'GPSLongitude',
			},
			ValueConv: '"$val[0] $val[1]"',
			PrintConv: '"$prt[0], $prt[1]"',
		},
		LensID: {
			Groups: { 2: 'Camera' },
			Require: 'LensType',
			Desire: {
				1: 'FocalLength',
				2: 'MaxAperture',
				3: 'MaxApertureValue',
				4: 'MinFocalLength',
				5: 'MaxFocalLength',
				6: 'LensModel',
				7: 'LensFocalRange',
				8: 'LensSpec',
				9: 'LensType2',
			},
			Notes: q{
				attempt to identify the actual lens from all lenses with a given LensType.
				Applies only to LensType values with a lookup table.  May be configured
				by adding user-defined lenses
			},
			# this LensID is only valid if the LensType has a PrintConv or is a model name
			RawConv: q{
				return $val if ref $$self{TAG_INFO}{LensType}{PrintConv} eq "HASH" or
								  $val[0] =~ /(mm|\d\/F)/;
				return undef;
			},
			ValueConv: '$val',
			PrintConv: q{
				my $pcv;
				# use LensType2 instead of LensType if available and valid (Sony E-mount lenses)
				if ($val[9] and $val[9] & 0x8000) {
					$val[0] = $val[9];
					$prt[0] = $prt[9];
					$pcv = $$self{TAG_INFO}{LensType2}{PrintConv};
				}
				Image::ExifTool::Exif::PrintLensID($self, $prt[0], $pcv, $prt[8], @val);
			},
		},
	);
	*/
}